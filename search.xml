<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c/c++天天酷跑</title>
      <link href="/2023/02/27/2023-2-10-%E5%A4%A9%E5%A4%A9%E9%85%B7%E8%B7%91/"/>
      <url>/2023/02/27/2023-2-10-%E5%A4%A9%E5%A4%A9%E9%85%B7%E8%B7%91/</url>
      
        <content type="html"><![CDATA[<h2 id="图形化界面小游戏"><a href="#图形化界面小游戏" class="headerlink" title="图形化界面小游戏"></a>图形化界面小游戏</h2><p>&#x2F;*<br>    开发日志<br>    1.创建项目<br>    2.导入素材<br>    3.创建游戏界面<br>    从用户界面入手</p><pre><code>选择图形库或者其他引擎，酷跑是基于“easyx”图形库的1）创建游戏窗口2）设计游戏背景    a.三重背景不同的速度移动    b.循环滚动背景的实现3)实现游戏背景    a.加载背景资源    b.渲染（实现打印图片的效果）背景知识：坐标    遇到的问题：背景图片的png格式图片出现黑色4.实现玩家奔跑5.实现玩家跳跃6.实现随机小乌龟7.创建结构体结构类型8.使用障碍物结构体后重新初始化9.封装后多个障碍物的显示10.实现玩家的下蹲技能11.实现“柱子”障碍物</code></pre><p>*&#x2F;<br>&#x2F;&#x2F;#undef UNICODE<br>&#x2F;&#x2F;#undef _UNICODE</p><p>#include &lt;stdio.h&gt;<br>#include &lt;graphics.h&gt;<br>#include &lt;conio.h&gt;<br>#include <vector> &#x2F;&#x2F;c++ 长度可变的数组<br>#include “tools.h”</p><p>using namespace std; &#x2F;&#x2F;声明命名空间<br>#define WIN_SCORE 10</p><p>#define WIN_WIDTH 1012 &#x2F;&#x2F;定义宏 便于后期维护与处理<br>#define WIN_HEIGHT 396<br>#define OBSTACLE_COUNT 10</p><p>IMAGE imgBgs[3];&#x2F;&#x2F;背景图片——创建图片数组<br>int bgX[3];&#x2F;&#x2F;背景图片的X坐标（不断变化）<br>int bgSpeed[3] &#x3D; { 1,2,4 };&#x2F;&#x2F;控制3个背景不同速度</p><p>IMAGE imgHeros[12];&#x2F;&#x2F;人物不断奔跑的实现<br>int heroX;&#x2F;&#x2F;玩家的X坐标<br>int heroY;&#x2F;&#x2F;玩家的Y坐标<br>int heroIndex;&#x2F;&#x2F;玩家奔跑的图片帧序号</p><p>bool heroJump;&#x2F;&#x2F;表示玩家正在跳跃<br>int jumpHeightMax;&#x2F;&#x2F;跳跃的最大高度<br>int heroJumpOff;&#x2F;&#x2F;跳跃偏移量<br>int update;&#x2F;&#x2F;表示是否需要马上刷新画面</p><p>&#x2F;&#x2F;IMAGE imgTortoise; &#x2F;&#x2F;小乌龟<br>&#x2F;&#x2F;int torToiseX; &#x2F;&#x2F;小乌龟的水平坐标<br>&#x2F;&#x2F;int torToiseY; &#x2F;&#x2F;小乌龟的竖直坐标<br>&#x2F;&#x2F;bool torToiseExist; &#x2F;&#x2F;当前窗口是否有小乌龟</p><p>int heroBlood; &#x2F;&#x2F;定义玩家血量<br>int score;</p><p>typedef enum {<br>    TORTOISE, &#x2F;&#x2F;乌龟 0<br>    LION, &#x2F;&#x2F;狮子 1<br>    HOOK1,<br>    HOOK2,<br>    HOOK3,<br>    HOOK4,<br>    OBSTACLE_TYPE_COUNT &#x2F;&#x2F;边界 6<br>}obstacle_type;</p><p>&#x2F;&#x2F; 相当于 IMAGE obstacleImgs[3][5]<br>vector&lt;vector<IMAGE>&gt;obstacleImgs; &#x2F;&#x2F;二维数组 存放所有障碍物的各个图片</p><p>typedef struct obstacle {<br>    int type; &#x2F;&#x2F;障碍物的类型<br>    int imgIndex; &#x2F;&#x2F;当前显示的图片的序号<br>    int x, y; &#x2F;&#x2F;障碍物的坐标<br>    int speed;<br>    int power; &#x2F;&#x2F;杀伤力<br>    bool exist;<br>    bool hited;  &#x2F;&#x2F;表示是否已经发生碰撞<br>    bool passed;&#x2F;&#x2F;表示是否已经被通过<br>}obstacle_t;</p><p>obstacle_t obstacles[OBSTACLE_COUNT];<br>int lastObsIndex;&#x2F;&#x2F;解决障碍物bug（柱子与狮子在一起）</p><p>IMAGE imgHeroDown[2];<br>bool heroDown; &#x2F;&#x2F;表示玩家是否处于下蹲状态</p><p>IMAGE imgSZ[10];</p><p>&#x2F;&#x2F;游戏的初始化<br>void init() {<br>    &#x2F;&#x2F;创建游戏窗口<br>    initgraph(WIN_WIDTH, WIN_HEIGHT, EW_SHOWCONSOLE);</p><pre><code>//加载背景资源char name[64];for (int i = 0; i &lt; 3; i++)&#123;    //路径 &quot;res/bg001.png&quot; &quot;res/bg002.png&quot; &quot;res/bg003.png&quot;    sprintf(name, &quot;res/bg%03d.png&quot;,i+1);//%03d占3位，不足3位自动补0    //#undef _UNICODE      loadimage(&amp;imgBgs[i], name);//把3个图片加载到了图片数组的位置    bgX[i] = 0;&#125;//加载Hero奔跑的图片帧素材for (int i = 0; i &lt; 12; i++) &#123;    sprintf(name, &quot;res/hero%d.png&quot;, i + 1);    loadimage(&amp;imgHeros[i], name);&#125; //设置玩家的初始位置heroX = WIN_WIDTH * 0.5 - imgHeros[0].getwidth() * 0.5;//X坐标：屏幕宽度的一半减去人物宽度的一半heroY = 345 - imgHeros[0].getheight();//Y坐标：脚底坐标减去人物高度heroIndex = 0;heroJump = false;jumpHeightMax = 345 - imgHeros[0].getheight() - 120;heroJumpOff = -4;update = true;////加载小乌龟素材//loadimage(&amp;imgTortoise, &quot;res/t1.png&quot;);//torToiseExist = false;//torToiseY = 345 - imgTortoise.getheight() + 5;IMAGE imgTort;loadimage(&amp;imgTort, &quot;res/t1.png&quot;);vector&lt;IMAGE&gt;imgTortArray;imgTortArray.push_back(imgTort);//添加图片obstacleImgs.push_back(imgTortArray);IMAGE imgLion;vector&lt;IMAGE&gt;imgLionArray;for (int i = 0; i &lt; 6; i++) &#123;    sprintf(name, &quot;res/p%d.png&quot;, i + 1);    loadimage(&amp;imgLion, name);    imgLionArray.push_back(imgLion);&#125;obstacleImgs.push_back(imgLionArray);//初始化障碍物池for (int i = 0; i &lt; OBSTACLE_COUNT; i++) &#123;    obstacles[i].exist = false;&#125;//加载下蹲素材loadimage(&amp;imgHeroDown[0], &quot;res/d1.png&quot;);loadimage(&amp;imgHeroDown[1], &quot;res/d2.png&quot;);heroDown = false;//加载柱子图片IMAGE imgH;for (int i = 0; i &lt; 4; i++) &#123;    vector&lt;IMAGE&gt; imgHookArray;    sprintf(name, &quot;res/h%d.png&quot;, i + 1);    loadimage(&amp;imgH, name, 63, 250, true); // 图片进行缩化    imgHookArray.push_back(imgH);    obstacleImgs.push_back(imgHookArray);&#125;heroBlood = 100;//预加载音效preLoadSound(&quot;res/hit.mp3&quot;);//背景音乐mciSendString(&quot;play res/bg.mp3 repeat&quot;, 0, 0, 0);lastObsIndex = -1;score = 0;//加载数字图片for (int i = 0; i &lt; 10; i++) &#123;    sprintf(name, &quot;res/sz/%d.png&quot;, i);    loadimage(&amp;imgSZ[i], name);&#125;</code></pre><p>}</p><p>&#x2F;&#x2F;随机创建障碍物<br>void creatObstacle() {<br>    int i;<br>    for (i &#x3D; 0; i &lt; OBSTACLE_COUNT; i++) {<br>        if (obstacles[i].exist &#x3D;&#x3D; false) {<br>            break;<br>        }<br>    }<br>    if (i &gt;&#x3D; OBSTACLE_COUNT) {<br>        return;<br>    }</p><pre><code>obstacles[i].exist = true;obstacles[i].hited = false;obstacles[i].imgIndex = 0;//obstacles[i].type = (obstacle_type)(rand() % OBSTACLE_TYPE_COUNT);obstacles[i].type = (obstacle_type)(rand() % 3);//如果上一个障碍物是柱子，下一个是狮子，判断距离，若很近，则狮子换为乌龟if (lastObsIndex &gt;= 0 &amp;&amp; obstacles[lastObsIndex].type &gt;= HOOK1 &amp;&amp; obstacles[lastObsIndex].type &lt;= HOOK4 &amp;&amp; obstacles[i].type == LION &amp;&amp; obstacles[lastObsIndex].x &gt; WIN_WIDTH - 500) &#123;    obstacles[i].type == TORTOISE;&#125;lastObsIndex = i;if (obstacles[i].type == HOOK1) &#123; //降低柱子出现的频率    obstacles[i].type += rand() % 4; //0-3&#125;obstacles[i].x = WIN_WIDTH;obstacles[i].y = 345 + 5 - obstacleImgs[obstacles[i].type][0].getheight();if (obstacles[i].type == TORTOISE) &#123;    obstacles[i].speed = 0;    obstacles[i].power = 5; //随意&#125;else if (obstacles[i].type == LION) &#123;    obstacles[i].speed = 1;    obstacles[i].power = 20;&#125;else if (obstacles[i].type &gt;= HOOK1 &amp;&amp; obstacles[i].type &lt;= HOOK4) &#123;    obstacles[i].speed = 0;    obstacles[i].power = 20;    obstacles[i].y = 0;&#125;obstacles[i].passed = false;</code></pre><p>}</p><p>void checkHit() {<br>    for(int i &#x3D; 0; i &lt; OBSTACLE_COUNT; i++) {<br>        if (obstacles[i].exist &amp;&amp; obstacles[i].hited &#x3D;&#x3D; false) {<br>            int a1x, a1y, a2x, a2y;<br>            int off &#x3D; 30;<br>            if (!heroDown) { &#x2F;&#x2F;非下蹲 奔跑 跳跃<br>                a1x &#x3D; heroX + off;<br>                a1y &#x3D; heroY + off;<br>                a2x &#x3D; heroX + imgHeros[heroIndex].getwidth() - off;<br>                a2y &#x3D; heroY + imgHeros[heroIndex].getheight();<br>            }<br>            else {<br>                a1x &#x3D; heroX + off;<br>                a1y &#x3D; 345 - imgHeroDown[heroIndex].getheight();<br>                a2x &#x3D; heroX + imgHeroDown[heroIndex].getwidth() - off;<br>                a2y &#x3D; 345;<br>            }</p><pre><code>        IMAGE img = obstacleImgs[obstacles[i].type][obstacles[i].imgIndex]; //当前障碍物类型（的第几张图片）        int b1x = obstacles[i].x + off;        int b1y = obstacles[i].y + off;        int b2x = obstacles[i].x + img.getwidth() - off;        int b2y = obstacles[i].y + img.getheight() - 10;        if (rectIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y)) &#123;            heroBlood -= obstacles[i].power;            printf(&quot;血量剩余 %d\n&quot;, heroBlood);            playSound(&quot;res/hit.mp3&quot;);            obstacles[i].hited = true;        &#125;    &#125;&#125;</code></pre><p>}</p><p>&#x2F;&#x2F;让背景动起来<br>void run() {<br>    for (int i &#x3D; 0; i &lt; 3; i++) {<br>        bgX[i] -&#x3D; bgSpeed[i];&#x2F;&#x2F;3个背景移动的速度不同<br>        if (bgX[i] &lt; -WIN_WIDTH) {<br>            bgX[i] &#x3D; 0;<br>        }<br>    }</p><pre><code>//实现跳跃if (heroJump) &#123;    if (heroY &lt; jumpHeightMax) //达到最大跳跃高度 跳跃偏移量为正 向下跳跃    &#123;         heroJumpOff = 4;    &#125;    heroY += heroJumpOff;    if (heroY &gt; 345 - imgHeros[0].getheight()) //到达地面 跳跃结束    &#123;          heroJump = false;        heroJumpOff = -4; // 偏移量初始化    &#125;&#125;else if (heroDown) &#123; //人物下蹲    static int count = 0;    int delays[2] = &#123; 8,30 &#125;; //设置下蹲的时间不一样    count++;    if (count &gt;= delays[heroIndex]) &#123;        count = 0;        heroIndex++;        if (heroIndex &gt;= 2) &#123;            heroIndex = 0;            heroDown = false;        &#125;    &#125;&#125;else&#123; //不跳跃    heroIndex = (heroIndex + 1) % 12; //12张图片循环播放完成一系列动作&#125;//创建障碍物static int frameCount = 0;static int enemyFre = 50;frameCount++;if (frameCount &gt; enemyFre)&#123;    frameCount = 0;    //if (!torToiseExist) &#123; //避免屏幕同时出现多个小乌龟    //torToiseExist = true;    //torToiseX = WIN_WIDTH;    //enemyFre=rand()%301+200; //每200-500帧随机出现一只龟    //&#125;    enemyFre = rand() % 50 + 50;    creatObstacle();&#125;//if (torToiseExist) &#123;////更新小乌龟位置//torToiseX -= bgSpeed[2];//if (torToiseX &lt; -imgTortoise.getwidth()) &#123;//torToiseExist = false;//&#125;//&#125;//更新所有障碍物的坐标for (int i = 0; i &lt; OBSTACLE_COUNT; i++) &#123;    if (obstacles[i].exist) &#123;        obstacles[i].x -= obstacles[i].speed + bgSpeed[2];        if (obstacles[i].x &lt; -obstacleImgs[obstacles[i].type][0].getwidth() * 2) &#123;            obstacles[i].exist = false;        &#125;        int len = obstacleImgs[obstacles[i].type].size();        obstacles[i].imgIndex = (obstacles[i].imgIndex + 1) % len;    &#125;&#125;//玩家和障碍物的“碰撞检测”处理checkHit();</code></pre><p>}</p><p>&#x2F;&#x2F;渲染“游戏背景”<br>void updateBg() {<br>    &#x2F;&#x2F;调整背景图片位置<br>    putimagePNG2(bgX[0], 0, &amp;imgBgs[0]);<br>    putimagePNG2(bgX[1], 119, &amp;imgBgs[1]);<br>    putimagePNG2(bgX[2], 330, &amp;imgBgs[2]);</p><p>}</p><p>&#x2F;&#x2F;实现跳跃<br>void jump() {<br>    heroJump &#x3D; true;<br>    update &#x3D; true; &#x2F;&#x2F;未处于刷新时也能跳跃<br>}</p><p>void down() {<br>    update &#x3D; true;<br>    heroDown &#x3D; true;<br>    heroIndex &#x3D; 0;<br>}</p><p>&#x2F;&#x2F;处理用户按键的输入<br>void keyEvent() {</p><pre><code>//char c;//scanf(&quot;%c&quot;, &amp;c);   会直接阻塞程序的执行if (GetAsyncKeyState(VK_UP))&#123; //虚拟键    jump();    /*        if(kbhit())   //kbhit()判断有无键盘输入。若有按键按下，则kbhit()返回 TRUE        &#123;            char ch = _getch();//不需要按下回车即可直接读取            if (ch == &#39; &#39;) &#123;//按下空格跳跃                jump();        &#125;    */&#125;else if (GetAsyncKeyState(VK_DOWN)) &#123;    down();&#125;</code></pre><p>}</p><p>void updateEnemy() {<br>    &#x2F;&#x2F;渲染小乌龟<br>    &#x2F;<em>if (torToiseExist) {<br>        putimagePNG2(torToiseX, torToiseY, WIN_WIDTH, &amp;imgTortoise);<br>    }</em>&#x2F;<br>    for (int i &#x3D; 0; i &lt; OBSTACLE_COUNT; i++) {<br>        if (obstacles[i].exist) {<br>            putimagePNG2(obstacles[i].x, obstacles[i].y, WIN_WIDTH, &amp;obstacleImgs[obstacles[i].type][obstacles[i].imgIndex]);<br>        }<br>    }<br>}</p><p>void updateHero() {<br>    if (!heroDown) { &#x2F;&#x2F;不处于下蹲状态——奔跑跳跃<br>        putimagePNG2(heroX, heroY, &amp;imgHeros[heroIndex]);<br>    }<br>    else {<br>        int y &#x3D; 345 - imgHeroDown[heroIndex].getheight();<br>        putimagePNG2(heroX, y, &amp;imgHeroDown[heroIndex]);<br>    }<br>}</p><p>void updateBloodBar()<br>{<br>    drawBloodBar(10, 10, 200, 10, 2, BLUE, DARKGRAY, RED, heroBlood &#x2F; 100.0);<br>}</p><p>void checkOver() {<br>    if (heroBlood &lt;&#x3D; 0) {<br>        loadimage(0, “res&#x2F;over.png”);<br>        FlushBatchDraw();&#x2F;&#x2F;刷新<br>        mciSendString(“stop res &#x2F; bg.mp3”, 0, 0, 0);&#x2F;&#x2F;关掉背景音乐<br>        system(“pause”);</p><pre><code>    //暂停之后，充币复活或者直接开始下一局    heroBlood = 100;    score = 0;    mciSendString(&quot;play res / bg.mp3 repeat&quot;, 0, 0, 0);&#125;</code></pre><p>}</p><p>void checkScore() {<br>    for (int i &#x3D; 0; i &lt; OBSTACLE_COUNT; i++) {<br>        if (obstacles[i].exist &amp;&amp; obstacles[i].passed &#x3D;&#x3D; false &amp;&amp;<br>            obstacles[i].x + obstacleImgs[obstacles[i].type][0].getwidth() &lt; heroX &amp;&amp; obstacles[i].hited &#x3D;&#x3D; false)<br>        {<br>            score++;<br>            obstacles[i].passed &#x3D; true;<br>            printf(“score:%d\n”, score);<br>        }<br>    }<br>}</p><p>void updateScore() {<br>    char str[8];<br>    sprintf(str, “%d”, score);</p><pre><code>int x = 20;int y = 25;for (int i = 0; str[i]; i++) &#123;    int sz = str[i] - &#39;0&#39;;    putimagePNG(x, y, &amp;imgSZ[sz]);    x += imgSZ[sz].getwidth() + 5;&#125;</code></pre><p>}</p><p>void checkWin() {<br>    if (score &gt;&#x3D; WIN_SCORE) {<br>        FlushBatchDraw();<br>        mciSendString(“play res&#x2F;win.mp3”, 0, 0, 0);<br>        Sleep(2000);<br>        loadimage(0, “res&#x2F;win.png”);<br>        FlushBatchDraw();<br>        mciSendString(“stop res&#x2F;bg.mp3”, 0, 0, 0);<br>        system(“pause”);</p><pre><code>    heroBlood = 100;    score = 0;    mciSendString(&quot;play res/bg.mp3 repeat&quot;, 0, 0, 0);&#125;</code></pre><p>}</p><p>int main(void)<br>{<br>    init();</p><pre><code>//显示初始化面loadimage(0, &quot;res/over.png&quot;);system(&quot;pause&quot;);int timer = 0;while (1) &#123;    keyEvent();    timer += getDelay();//此函数返回距离上一次调用间隔的时间，第一次返回0    if (timer &gt; 30) &#123; //30毫秒刷新时间        timer = 0;        update = true;    &#125;    if (update) &#123;        update = false;        BeginBatchDraw();//这个函数用于开始批量绘图。执行后，任何绘图操作都将暂时不输出到绘图窗口上，直到执行 FlushBatchDraw 或 EndBatchDraw 才将之前的绘图输出。        updateBg();        //putimagePNG2(heroX, heroY, &amp;imgHeros[heroIndex]);        updateHero();        updateEnemy();        updateBloodBar();        updateScore();        checkWin();        EndBatchDraw();//这个函数用于结束批量绘制，并执行未完成的绘制任务。   这两个函数主要为了消除闪烁。        checkOver();        checkScore();                run();    &#125;        //Sleep(30); //休眠&#125;system(&quot;pause&quot;);return 0;</code></pre><p>}</p><h2 id="End-By-siren"><a href="#End-By-siren" class="headerlink" title="End! By siren"></a>End! By siren</h2>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c/c++贪吃蛇</title>
      <link href="/2023/02/10/2022-1-25-%E8%B4%AA%E5%90%83%E8%9B%87/"/>
      <url>/2023/02/10/2022-1-25-%E8%B4%AA%E5%90%83%E8%9B%87/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一个小游戏"><a href="#这是我的第一个小游戏" class="headerlink" title="这是我的第一个小游戏"></a>这是我的第一个小游戏</h2><p>#define _CRT_SECURE_NO_WARNINGS<br>#include”snake.h”</p><p>&#x2F;&#x2F;得分<br>int score &#x3D; 0;</p><p>&#x2F;&#x2F;吃掉每一个食物的得分<br>int add &#x3D; 1;</p><p>&#x2F;&#x2F;结束的标志<br>int endStatus &#x3D; 0;</p><p>&#x2F;&#x2F;链表的头指针<br>snake_t* head &#x3D; NULL;</p><p>&#x2F;&#x2F;食物的节点指针<br>snake_t* foodNode &#x3D; NULL;</p><p>int main()<br>{<br>    int choice &#x3D; 0;</p><pre><code>//设置控制台宽高system(&quot;mode con cols=100 lines=30&quot;);//设置随机种子rand(time(NULL));//循环接受用户选择while (1)&#123;    //显示欢迎页面    choice= welcomeGame();    switch (choice)    &#123;    case 1:        //printf(&quot;开始游戏&quot;);        printMap();//打印地图        //showScoreTips();//显示提示信息        initSnake();//初始化蛇        randFood();//随机食物        //通过按键实现蛇的移动        moveKeyControl();        break;    case 2:        aboutGame();        break;    case 3:        //printf(&quot;退出游戏&quot;);        //系统提供的函数 退出程序        exit(0);        break;    default:        setColor(12);        gotoXY(45, 28);        printf(&quot;输入非法，按下回车键继续。&quot;);        //按任意键        getchar();    &#125;    //按下回车键继续    getchar();&#125;system(&quot;pause&quot;);return 0;</code></pre><p>}</p><p>&#x2F;&#x2F;设置文本的颜色<br>int setColor(int c)<br>{<br>    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),c);<br>    return 0;<br>}</p><p>&#x2F;&#x2F;设置光标的位置<br>int gotoXY(int x, int y)<br>{<br>    &#x2F;&#x2F;坐标结构体类型<br>    COORD c;<br>    &#x2F;&#x2F;横坐标 纵坐标<br>    c.X &#x3D; x;<br>    c.Y &#x3D; y;</p><pre><code>//STD_OUTPUT_HANDLE 表示标准输出//GetStdHandle(STD_OUTPUT_HANDLE) 获取当前标准输出句柄//c 坐标值SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), c);return 0;</code></pre><p>}</p><p>&#x2F;&#x2F;绘制字符画-蛇<br>int printfsnake(void)<br>{<br>    &#x2F;&#x2F;清屏<br>    system(“cls”);</p><pre><code>gotoXY(35, 1);setColor(6);printf(&quot;/^\\/^\\&quot;); //蛇眼睛gotoXY(34,2);printf(&quot;|__|  o|&quot;); //蛇眼睛gotoXY(33, 2);setColor(2);printf(&quot;_&quot;); gotoXY(25,3);setColor(12);printf(&quot;\\/&quot;); //蛇信gotoXY(31, 3);setColor(2);printf(&quot;/&quot;); gotoXY(37,31);setColor(6);printf(&quot;\\_/&quot;); //蛇眼睛gotoXY(41, 3);setColor(10);printf(&quot;\\&quot;); gotoXY(26,4);setColor(12);printf(&quot;\\___&quot;); //舌头gotoXY(32,4);printf(&quot;________/&quot;); gotoXY(31,4);setColor(2);printf(&quot;|&quot;); gotoXY(43,4);setColor(10);printf(&quot;\\&quot;); gotoXY(32,5);setColor(2);printf(&quot;\\______&quot;); //蛇嘴gotoXY(44,5);setColor(10);printf(&quot;\\&quot;); gotoXY(39,6);printf(&quot;|      |               \\&quot;); //下面是蛇身gotoXY(38,7);printf(&quot;/      /                 \\&quot;);gotoXY(37,8);printf(&quot;/      /                  \\ \\&quot;);gotoXY(35,9);printf(&quot;/      /                     \\  \\&quot;);gotoXY(34,10);printf(&quot;/      /                        \\  \\&quot;);gotoXY(33,11);printf(&quot;/      /            _----_         \\  \\&quot;);gotoXY(32,12);printf(&quot;/      /          _-~    ~-_          |   |&quot;);gotoXY(31,13);printf(&quot;(      (        _-~  _--_   ~-_       _/    |&quot;);gotoXY(32, 14);printf(&quot;\\      ~-___-~    _-~   ~-_    ~~_~~      /&quot;);gotoXY(33, 15);printf(&quot;~-_           _-~         ~-_        _-~&quot;);gotoXY(35,16);printf(&quot;~--______-~                ~-___-~&quot;);return 0;</code></pre><p>}</p><p>int welcomeGame()<br>{<br>    printfsnake();</p><pre><code>setColor(11);gotoXY(45,18);printf(&quot;欢迎来到贪吃蛇游戏!&quot;);int i, j;int choice;//绘制边框setColor(14);//控制行for (i = 20; i &lt;= 26; i++)&#123;    //控制列    for (j = 27; j &lt;= 74; j++)    &#123;        //输出上下边框        if (i == 20 || i == 26)        &#123;            gotoXY(j, i);            printf(&quot;-&quot;);        &#125;        //输出左右边框        if (j == 27 || j == 74)        &#123;            gotoXY(j, i);            printf(&quot;|&quot;);        &#125;        else            printf(&quot; &quot;);    &#125;&#125;//输出菜单选项//设置文本属性setColor(12);gotoXY(35, 22);printf(&quot;1.开始游戏&quot;);gotoXY(55, 22);printf(&quot;2.游戏说明&quot;);gotoXY(35, 24);printf(&quot;3.退出游戏&quot;);gotoXY(27, 27);printf(&quot;请选择[1,2,3]:&quot;);scanf(&quot;%d&quot;, &amp;choice);return choice;</code></pre><p>}</p><p>int aboutGame(void)<br>{<br>    int i &#x3D; 0,j &#x3D; 0;</p><pre><code>//清屏system(&quot;cls&quot;);//输出标题setColor(13);gotoXY(44,3);printf(&quot;游戏说明&quot;);//输出边框//控制行for (i = 6; i &lt;= 22; i++)&#123;    //控制列    for (j = 20; j &lt;= 75; j++)    &#123;        //上下边框        if (i == 6 || i == 22)        &#123;            gotoXY(j, i);            printf(&quot;=&quot;);        &#125;        //左右边框        if (j == 20 || j == 75)        &#123;            gotoXY(j, i);            printf(&quot;|&quot;);        &#125;        else            printf(&quot; &quot;);//输出空格    &#125;&#125;//输出菜单选项setColor(3);gotoXY(30, 8);printf(&quot;1.不能撞到墙，不能吃到自己&quot;);setColor(5);gotoXY(30, 11);printf(&quot;2.F1加速前进，F2减速前进&quot;);setColor(11);gotoXY(30, 14);printf(&quot;3.使用空格键暂停游戏或继续游戏&quot;);setColor(13);gotoXY(30, 17);printf(&quot;4.使用方向键控制前进的方向&quot;);setColor(14);gotoXY(30, 20);printf(&quot;5.按下ESC键退出游戏&quot;);setColor(12);gotoXY(20,24);printf(&quot;按下回车键回到主界面&quot;);getchar();//按下回车键继续return 0;</code></pre><p>}</p><p>int printMap(void)<br>{<br>    int i &#x3D; 0, j &#x3D; 0;<br>    &#x2F;&#x2F;清屏<br>    system(“cls”);</p><pre><code>//控制行for (i = 0; i &lt;= 26; i++)&#123;    //控制列    for (j = 0; j &lt;= 56; j=j+2)    &#123;        //控制光标        gotoXY(j, i);        if (0 == i || 26 == i || 0 == j || 56 == j)        &#123;            setColor(13);            printf(&quot;□&quot;);        &#125;        else        &#123;            setColor(3);            printf(&quot;■&quot;);//■        &#125;    &#125;&#125;//getchar();//按下回车键继续return 0;</code></pre><p>}</p><p>&#x2F;&#x2F;显示分数和提示信息<br>int showScoreTips(void)<br>{<br>    int highscore &#x3D; 0;</p><pre><code>//从文件中读取最高分highscore = readFile();//显示最高分setColor(3);gotoXY(64, 4);printf(&quot;※※历史最高分※※：%d&quot;,highscore);//显示当前得分setColor(14);gotoXY(64, 8);printf(&quot;※※当前得分※※：%d&quot;,score);//显示温馨提示setColor(12);gotoXY(72, 11);printf(&quot;温馨提示&quot;);//绘制上下边框setColor(10);gotoXY(60, 13);printf(&quot;==============================&quot;);gotoXY(60, 25);printf(&quot;==============================&quot;);//输出温馨提示setColor(13);gotoXY(64, 14);printf(&quot;※ 吃掉每个食物得分：%d&quot;,add);gotoXY(64, 16);printf(&quot;※ 不能撞到墙壁，不能咬到自己&quot;);gotoXY(64, 18);printf(&quot;※ F1加速前进，F2减速前进&quot;);gotoXY(64, 20);printf(&quot;※ 按下空格暂停游戏或继续游戏&quot;);gotoXY(64, 22);printf(&quot;※ 使用←→↑↓控制前进的方向&quot;);gotoXY(64, 24);printf(&quot;※ 按下ESC退出游戏&quot;);//getchar();//按下回车键继续return 0;</code></pre><p>}</p><p>&#x2F;&#x2F;从save.txt文件中读取最高分<br>int readFile(void)<br>{<br>    int ret &#x3D; -1;<br>    char buf[32];</p><pre><code>FILE* fp = NULL;//1以只读的方式打开文件夹fp = fopen(&quot;save.txt&quot;, &quot;r&quot;);if (NULL == fp)&#123;    printf(&quot;fopen failed...\n&quot;);    return 0;&#125;//2读取文件内容memset(buf, 0, sizeof(buf));ret = fread(buf, sizeof(char), sizeof(buf), fp);if (ret &lt;= 0)&#123;    printf(&quot;fread failed...\n&quot;);    return 0;&#125;//3关闭文件fclose(fp);//atoi--&gt;将字符串数字转化为数字 “123”-&gt;123return atoi(buf);</code></pre><p>}</p><p>&#x2F;&#x2F;初始化蛇<br>int initSnake(void)<br>{<br>    &#x2F;&#x2F;system(“cls”);<br>    int i &#x3D; 0;</p><pre><code>snake_t * new = NULL;snake_t * tmp = NULL;//循环创造4个节点for (i = 0; i &lt; 4; i++)&#123;    //分配空间    new = malloc(sizeof(snake_t));    if (NULL == new)    &#123;        printf(&quot;malloc initSnake failed...\n&quot;);        return -1;    &#125;    memset(new, 0, sizeof(snake_t));    //赋值    new-&gt;x = 24 + i * 2;    new-&gt;y = 5;    //头插法    new-&gt;next = head;    head = new;&#125;//遍历链表tmp = head;while (tmp != NULL)&#123;    //设置蛇的颜色 14 黄色    setColor(14);    //定位光标    gotoXY(tmp-&gt;x, tmp-&gt;y);    if (tmp == head)    &#123;        printf(&quot;●&quot;); //●    &#125;    printf(&quot;★&quot;);//★    tmp = tmp-&gt;next;&#125;return 0;</code></pre><p>}</p><p>&#x2F;&#x2F;随机食物<br>int randFood(void)<br>{<br>    snake_t* tmp &#x3D; NULL;</p><pre><code>//随机的食物不能出现在墙壁上//随机的食物不能出现在蛇身上//随机的食物x坐标一定是偶数//分配空间foodNode = malloc(sizeof(snake_t));if (NULL == foodNode)&#123;    gotoXY(1, 28);    printf(&quot;malloc failed...&quot;);    return -1;&#125;memset(foodNode, 0, sizeof(snake_t));while (1)&#123;    while (1)    &#123;        //保证X坐标是偶数 同时不应该出现在墙上   坐标应为：（2,54）        foodNode-&gt;x = rand() % 53 + 2;        if (0 == foodNode-&gt;x % 2)            break;    &#125;    //y的坐标是（1,25）    foodNode-&gt;y = rand() % 25 + 1;    //食物没有在蛇身上    if (NULL == tmp)    &#123;        gotoXY(foodNode-&gt;x, foodNode-&gt;y);        setColor(12);        printf(&quot;●&quot;);        break;    &#125;    else    &#123;        continue;    &#125;&#125;//getchar();//按下回车键继续return 0;</code></pre><p>}</p><p>int moveSnake(void)<br>{<br>    snake_t* new &#x3D; NULL;<br>    snake_t* tmp &#x3D; NULL;<br>    snake_t* save &#x3D; NULL;</p><pre><code>new = malloc(sizeof(snake_t));if (NULL == new)&#123;    printf(&quot;malloc failed...\n&quot;);    return -1;&#125;memset(new, 0, sizeof(snake_t));//向上移动if (UP == direction)&#123;    new-&gt;x = head-&gt;x;    new-&gt;y = head-&gt;y - 1;&#125;//向下移动if (DOWN == direction)&#123;    new-&gt;x = head-&gt;x;    new-&gt;y = head-&gt;y + 1;&#125;//向右移动if (RIGHT == direction)&#123;    new-&gt;x = head-&gt;x + 2;    new-&gt;y = head-&gt;y;&#125;//向左移动if (LEFT == direction)&#123;    new-&gt;x = head-&gt;x - 2;    new-&gt;y = head-&gt;y;&#125;new-&gt;next = head;head = new;tmp = head;setColor(14);//判断是否为食物if ((new-&gt;x == foodNode-&gt;x) &amp;&amp; (new-&gt;y == foodNode-&gt;y))&#123;    //循环画出蛇    while (NULL != tmp) &#123;        gotoXY(tmp-&gt;x, tmp-&gt;y);        if (tmp == head)            printf(&quot;●&quot;);        else            printf(&quot;★&quot;);        tmp = tmp-&gt;next;    &#125;    //吃掉一个食物 增加分数    score = score + add;    //再随机食物    randFood();&#125;else&#123;    while (NULL != tmp-&gt;next)    &#123;        gotoXY(tmp-&gt;x, tmp-&gt;y);        if (tmp == head)            printf(&quot;●&quot;);        else            printf(&quot;★&quot;);        save = tmp;        tmp = tmp-&gt;next;    &#125;    //将最后一个节点释放    gotoXY(tmp-&gt;x, tmp-&gt;y);    setColor(3);    printf(&quot;■&quot;);    save-&gt;next = NULL;    free(tmp);&#125;return 0;</code></pre><p>}</p><p>int moveKeyControl(void)<br>{<br>    direction &#x3D; RIGHT;</p><pre><code>while (1)&#123;    showScoreTips();    //向上    if (GetAsyncKeyState(VK_UP) &amp;&amp; direction != DOWN)    &#123;        direction = UP;    &#125;    //向下    if (GetAsyncKeyState(VK_DOWN) &amp;&amp; direction != UP)    &#123;        direction = DOWN;    &#125;    //向左    if (GetAsyncKeyState(VK_LEFT) &amp;&amp; direction != RIGHT)//GetAsyncKeyState获取键盘输入信息    &#123;        direction = LEFT;    &#125;    //向右    if (GetAsyncKeyState(VK_RIGHT) &amp;&amp; direction != LEFT)    &#123;        direction = RIGHT;    &#125;    //按下空格键暂停游戏或继续游戏    if (GetAsyncKeyState(VK_SPACE))    &#123;        while (1)        &#123;            Sleep(300);            if (GetAsyncKeyState(VK_SPACE))                break;        &#125;    &#125;    //按下F1键加速    if (GetAsyncKeyState(VK_F1))    &#123;        //减少睡眠的时间 但睡眠时间不少于50ms        speedUp();    &#125;    //按下F2键加速    if (GetAsyncKeyState(VK_F2))    &#123;        //增加睡眠的时间 但睡眠时间不大于350ms        speedDown();    &#125;    //按下ESC键结束游戏    if (GetAsyncKeyState(VK_ESCAPE))    &#123;        //表示用户按下ESC键结束游戏        endStatus = 3;        endGame();        //exit(1);        break;    &#125;    Sleep(sleepTime);    moveSnake();    //判断是否撞到墙    if (isHitWall())    &#123;        endStatus = 1;        endGame();        break;    &#125;    //判断是否咬到自己    if (isBitSelf())    &#123;        endStatus = 2;        endGame();        break;    &#125;&#125;getchar();return 0;</code></pre><p>}</p><p>&#x2F;&#x2F;加速蛇的移动<br>int speedUp(void)<br>{<br>    &#x2F;&#x2F;最快的速度 睡眠时间50ms<br>    while (sleepTime &gt; 50)<br>    {<br>        sleepTime &#x3D; sleepTime - 20;<br>        add &#x3D; add + 2;<br>    }</p><pre><code>return 0;</code></pre><p>}</p><p>&#x2F;&#x2F;减速蛇的移动<br>int speedDown(void)<br>{<br>    if (sleepTime &lt; 350)<br>    {<br>        sleepTime &#x3D; sleepTime + 20;<br>        &#x2F;&#x2F;减少增加的分数<br>        add &#x3D; add - 2;<br>    }</p><pre><code>if (add &lt;= 0)&#123;    add = 1;&#125;return 0;</code></pre><p>}</p><p>&#x2F;&#x2F;判断是否撞墙 撞墙返回1 否则返回0<br>int isHitWall()<br>{<br>    &#x2F;&#x2F;表示撞到墙壁<br>    if (head-&gt;x &#x3D;&#x3D; 0 || head-&gt;x &#x3D;&#x3D; 56 || head-&gt;y &#x3D;&#x3D; 0 || head-&gt;y &#x3D;&#x3D; 26)<br>    {<br>        return 1;<br>    }</p><pre><code>//表示没有撞到墙壁return 0;</code></pre><p>}</p><p>&#x2F;&#x2F;判断是否咬到自己 咬到自己返回1 否则返回0<br>int isBitSelf()<br>{<br>    snake_t* tmp &#x3D; NULL;</p><pre><code>//从第二个节点开始算tmp = head-&gt;next;while (NULL != tmp)&#123;    if ((head-&gt;x == tmp-&gt;x) &amp;&amp; (head-&gt;y == tmp-&gt;y))    &#123;        return 1;    &#125;    //指向下一个节点    tmp = tmp-&gt;next;&#125;return 0;</code></pre><p>}</p><p>&#x2F;&#x2F;游戏失败边框<br>void failGameUi()<br>{<br>    int i &#x3D; 0;</p><pre><code>//清屏system(&quot;cls&quot;);//显示游戏失败提示setColor(12);gotoXY(44, 3);printf(&quot;游 戏 失 败！&quot;);//设置边框的颜色setColor(11);gotoXY(17, 5);//绘制上边框printf(&quot;+----------------------------------------------------------------+&quot;);//绘制下边框gotoXY(17, 20);printf(&quot;+----------------------------------------------------------------+&quot;);//绘制左右边框for(i = 6; i &lt;= 19; i++)&#123;    gotoXY(17, i);    printf(&quot;|&quot;);    gotoXY(82, i);    printf(&quot;|&quot;);&#125;</code></pre><p>}</p><p>&#x2F;&#x2F;结束游戏<br>int endGame(void)<br>{<br>    int n;<br>    int highScore &#x3D; 0;</p><pre><code>while (1)&#123;    //显示游戏失败界面    failGameUi();    setColor(12);    gotoXY(38, 9);    //不同的状态 显示不同的失败提示 endStatus    switch (endStatus)    &#123;        //撞到墙壁    case 1:        printf(&quot;您撞到墙壁了，游戏结束！&quot;);        break;        //咬到自己    case 2:        printf(&quot;您咬到蛇身了，游戏结束！&quot;);        break;        //按下ESC键    case 3:        printf(&quot;您已经结束了游戏，游戏结束！&quot;);        break;    default:        break;    &#125;    //显示您的得分    setColor(13);    gotoXY(43, 12);    printf(&quot;您的得分：%d&quot;, score);    //显示最高分    //从文件中读取最高分    highScore = readFile();    if (score &gt; highScore)    &#123;        setColor(10);        gotoXY(38, 16);        printf(&quot;恭喜您，您已经破纪录了！&quot;);        //将最高分写入文件        writeFile(score);    &#125;    else    &#123;        setColor(10);        gotoXY(38, 16);        printf(&quot;加油哦，离最高分还差%d分&quot;, highScore - score);    &#125;    //输出用户选择的信息    gotoXY(25, 23);    setColor(12);    printf(&quot;再玩一局请输入：1&quot;);    gotoXY(52, 23);    printf(&quot;直接退出请输入：2&quot;);    gotoXY(46, 25);    setColor(11);    printf(&quot;请选择：&quot;);    scanf(&quot;%d&quot;, &amp;n);    getchar();    if (n == 1)    &#123;        score = 0;        sleepTime = 350;        add = 1;        destorySnake();        break;    &#125;    else if(n==2)    &#123;        exit(0);    &#125;    else    &#123;        setColor(12);        gotoXY(30, 27);        printf(&quot;您输入有误，请重新输入，按下回车继续...&quot;);        getchar();        //system(&quot;cls&quot;);    &#125;&#125;return 0;</code></pre><p>}</p><p>int writeFile(int score)<br>{<br>    FILE* fp &#x3D; NULL;</p><pre><code>//打开文件fp = fopen(&quot;save.txt&quot;, &quot;w+&quot;);if (NULL == fp)&#123;    printf(&quot;打开文件失败\n&quot;);    return -1;&#125;//将最高分写入文件中fprintf(fp, &quot;%d&quot;, score);//关闭文件fclose(fp);return 0;</code></pre><p>}</p><p>int destorySnake(void)<br>{<br>    snake_t* tmp &#x3D; NULL;<br>    snake_t* save &#x3D; NULL;</p><pre><code>tmp = head;while (NULL != tmp)&#123;    save = tmp-&gt;next;    free(tmp);    tmp = save;&#125;head = NULL;return 0;</code></pre><p>}</p><h2 id="End-By-siren"><a href="#End-By-siren" class="headerlink" title="End! By siren."></a>End! By siren.</h2>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/02/08/2023-2-8-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/02/08/2023-2-8-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><p>let me begin<br>this is my first blog<br>i just want to have a try<br>so…<br>let us go!</p>]]></content>
      
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
